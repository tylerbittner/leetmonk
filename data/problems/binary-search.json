{
  "id": "binary-search",
  "title": "Binary Search",
  "difficulty": "easy",
  "tags": ["binary-search", "array"],
  "description": "## Binary Search\n\nYou are managing a catalog of products in a warehouse. Products are indexed with unique integer codes and sorted in ascending order in a database. You need to quickly locate a specific product by its code.\n\nGiven a sorted array of integers `nums` and an integer `target`, return the **index** of `target` in the array, or `-1` if it does not exist.\n\nYou must write an algorithm with **O(log n)** runtime complexity.\n\n**Constraints:**\n- `1 <= nums.length <= 10^4`\n- `-10^4 <= nums[i], target <= 10^4`\n- All integers in `nums` are **unique**.\n- `nums` is sorted in ascending order.",
  "examples": [
    {
      "input": "nums = [-1, 0, 3, 5, 9, 12], target = 9",
      "output": "4",
      "explanation": "9 exists in nums at index 4."
    },
    {
      "input": "nums = [-1, 0, 3, 5, 9, 12], target = 2",
      "output": "-1",
      "explanation": "2 does not exist in nums so return -1."
    }
  ],
  "exampleCases": [
    {
      "input": {"nums": [-1, 0, 3, 5, 9, 12], "target": 9},
      "expected": 4,
      "explanation": "9 found at index 4"
    },
    {
      "input": {"nums": [-1, 0, 3, 5, 9, 12], "target": 2},
      "expected": -1,
      "explanation": "2 not in array"
    },
    {
      "input": {"nums": [5], "target": 5},
      "expected": 0,
      "explanation": "Single element found"
    },
    {
      "input": {"nums": [1, 3, 5, 7, 9], "target": 1},
      "expected": 0,
      "explanation": "Target is first element"
    }
  ],
  "hiddenCases": [
    {
      "input": {"nums": [5], "target": 3},
      "expected": -1,
      "explanation": "Single element not found"
    },
    {
      "input": {"nums": [1, 3, 5, 7, 9], "target": 9},
      "expected": 4,
      "explanation": "Target is last element"
    },
    {
      "input": {"nums": [1, 3, 5, 7, 9], "target": 5},
      "expected": 2,
      "explanation": "Target is middle element"
    },
    {
      "input": {"nums": [1, 3, 5, 7, 9], "target": 6},
      "expected": -1,
      "explanation": "Target between two elements"
    },
    {
      "input": {"nums": [-10, -5, 0, 5, 10], "target": -10},
      "expected": 0,
      "explanation": "Negative target at start"
    },
    {
      "input": {"nums": [-10, -5, 0, 5, 10], "target": 10},
      "expected": 4,
      "explanation": "Target at end"
    },
    {
      "input": {"nums": [-10, -5, 0, 5, 10], "target": 0},
      "expected": 2,
      "explanation": "Zero as target"
    },
    {
      "input": {"nums": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], "target": 7},
      "expected": 6,
      "explanation": "10 element array"
    },
    {
      "input": {"nums": [1, 2], "target": 2},
      "expected": 1,
      "explanation": "Two element array, last"
    },
    {
      "input": {"nums": [1, 2], "target": 1},
      "expected": 0,
      "explanation": "Two element array, first"
    },
    {
      "input": {"nums": [10000], "target": 10000},
      "expected": 0,
      "explanation": "Maximum value, single element"
    }
  ],
  "starterCode": {
    "python": "from typing import List\n\ndef binary_search(nums: List[int], target: int) -> int:\n    pass"
  },
  "functionName": "binary_search",
  "solutions": [
    {
      "label": "Linear Scan — O(n)",
      "approach": "obvious",
      "language": "python",
      "code": "from typing import List\n\ndef binary_search(nums: List[int], target: int) -> int:\n    for i, num in enumerate(nums):\n        if num == target:\n            return i\n    return -1",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "explanation": "Scan through the array from left to right. Return the index of the first match, or -1 if not found. Does not exploit the sorted property of the array.\n\nTime: O(n) | Space: O(1)"
    },
    {
      "label": "Binary Search — O(log n)",
      "approach": "optimal",
      "language": "python",
      "code": "from typing import List\n\ndef binary_search(nums: List[int], target: int) -> int:\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = left + (right - left) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1",
      "timeComplexity": "O(log n)",
      "spaceComplexity": "O(1)",
      "explanation": "Check the middle element. If it equals the target, return its index. If it is less than the target, the answer must be in the right half, so move left = mid + 1. If greater, search the left half with right = mid - 1. Each iteration eliminates half the remaining candidates, yielding logarithmic time.\n\nTime: O(log n) | Space: O(1)"
    }
  ],
  "hints": [
    "The array is sorted — you can eliminate half the remaining elements at each step.",
    "Use two pointers (left and right) and check the middle element each iteration."
  ],
  "lcEquivalent": "704. Binary Search"
}
