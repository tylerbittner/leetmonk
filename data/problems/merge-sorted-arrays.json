{
  "id": "merge-sorted-arrays",
  "title": "Merge Sorted Arrays",
  "difficulty": "easy",
  "tags": ["two-pointers", "array", "sorting"],
  "description": "## Merge Sorted Arrays\n\nYou are merging two sorted inventory lists into a single unified catalog. The first list has been pre-allocated with extra space at the end to accommodate the second list's entries.\n\nYou are given two integer arrays `nums1` and `nums2`, sorted in non-decreasing order, and two integers `m` and `n`, representing the number of elements in `nums1` and `nums2` respectively.\n\nMerge `nums2` into `nums1` **in-place** so that `nums1` becomes a single sorted array. Return `nums1`.\n\n`nums1` has a length of `m + n`, where the first `m` elements are valid and the last `n` elements are set to `0` as placeholders.\n\n**Constraints:**\n- `nums1.length == m + n`\n- `nums2.length == n`\n- `0 <= m, n <= 200`\n- `-10^9 <= nums1[i], nums2[i] <= 10^9`",
  "examples": [
    {
      "input": "nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3",
      "output": "[1,2,2,3,5,6]",
      "explanation": "Merged array: [1,2,2,3,5,6]."
    },
    {
      "input": "nums1 = [1], m = 1, nums2 = [], n = 0",
      "output": "[1]",
      "explanation": "nums2 is empty, nums1 unchanged."
    },
    {
      "input": "nums1 = [0], m = 0, nums2 = [1], n = 1",
      "output": "[1]",
      "explanation": "nums1 is empty (just a placeholder), result is [1]."
    }
  ],
  "exampleCases": [
    {
      "input": {"nums1": [1, 2, 3, 0, 0, 0], "m": 3, "nums2": [2, 5, 6], "n": 3},
      "expected": [1, 2, 2, 3, 5, 6],
      "explanation": "Standard merge"
    },
    {
      "input": {"nums1": [1], "m": 1, "nums2": [], "n": 0},
      "expected": [1],
      "explanation": "Empty nums2"
    },
    {
      "input": {"nums1": [0], "m": 0, "nums2": [1], "n": 1},
      "expected": [1],
      "explanation": "Empty nums1"
    },
    {
      "input": {"nums1": [2, 0], "m": 1, "nums2": [1], "n": 1},
      "expected": [1, 2],
      "explanation": "nums2 element is smaller"
    }
  ],
  "hiddenCases": [
    {
      "input": {"nums1": [1, 2, 3, 0, 0, 0], "m": 3, "nums2": [4, 5, 6], "n": 3},
      "expected": [1, 2, 3, 4, 5, 6],
      "explanation": "nums2 all larger"
    },
    {
      "input": {"nums1": [4, 5, 6, 0, 0, 0], "m": 3, "nums2": [1, 2, 3], "n": 3},
      "expected": [1, 2, 3, 4, 5, 6],
      "explanation": "nums2 all smaller"
    },
    {
      "input": {"nums1": [1, 1, 1, 0, 0, 0], "m": 3, "nums2": [1, 1, 1], "n": 3},
      "expected": [1, 1, 1, 1, 1, 1],
      "explanation": "All same values"
    },
    {
      "input": {"nums1": [0, 0], "m": 0, "nums2": [1, 2], "n": 2},
      "expected": [1, 2],
      "explanation": "nums1 empty"
    },
    {
      "input": {"nums1": [-5, -3, 0, 0, 0], "m": 2, "nums2": [-4, -2, 1], "n": 3},
      "expected": [-5, -4, -3, -2, 1],
      "explanation": "Negative numbers"
    },
    {
      "input": {"nums1": [1, 3, 5, 0, 0, 0], "m": 3, "nums2": [2, 4, 6], "n": 3},
      "expected": [1, 2, 3, 4, 5, 6],
      "explanation": "Interleaved values"
    },
    {
      "input": {"nums1": [1, 2, 4, 5, 6, 0], "m": 5, "nums2": [3], "n": 1},
      "expected": [1, 2, 3, 4, 5, 6],
      "explanation": "Insert single element in middle"
    },
    {
      "input": {"nums1": [5, 0], "m": 1, "nums2": [5], "n": 1},
      "expected": [5, 5],
      "explanation": "Duplicate values"
    },
    {
      "input": {"nums1": [1000000000, 0], "m": 1, "nums2": [-1000000000], "n": 1},
      "expected": [-1000000000, 1000000000],
      "explanation": "Extreme values"
    },
    {
      "input": {"nums1": [2, 2, 3, 0], "m": 3, "nums2": [1], "n": 1},
      "expected": [1, 2, 2, 3],
      "explanation": "Insert at beginning"
    }
  ],
  "starterCode": {
    "python": "from typing import List\n\ndef merge_sorted(nums1: List[int], m: int, nums2: List[int], n: int) -> List[int]:\n    pass"
  },
  "functionName": "merge_sorted",
  "solutions": [
    {
      "label": "Extra Space — O(m+n)",
      "approach": "obvious",
      "language": "python",
      "code": "from typing import List\n\ndef merge_sorted(nums1: List[int], m: int, nums2: List[int], n: int) -> List[int]:\n    temp = nums1[:m] + nums2[:n]\n    temp.sort()\n    for i in range(m + n):\n        nums1[i] = temp[i]\n    return nums1",
      "timeComplexity": "O((m+n) log(m+n))",
      "spaceComplexity": "O(m+n)",
      "explanation": "Copy valid elements from both arrays, sort, and write back. Simple but uses extra space and does not exploit the pre-sorted property.\n\nTime: O((m+n) log(m+n)) | Space: O(m+n)"
    },
    {
      "label": "Merge From End — O(m+n)",
      "approach": "optimal",
      "language": "python",
      "code": "from typing import List\n\ndef merge_sorted(nums1: List[int], m: int, nums2: List[int], n: int) -> List[int]:\n    p1, p2, write = m - 1, n - 1, m + n - 1\n    while p1 >= 0 and p2 >= 0:\n        if nums1[p1] > nums2[p2]:\n            nums1[write] = nums1[p1]\n            p1 -= 1\n        else:\n            nums1[write] = nums2[p2]\n            p2 -= 1\n        write -= 1\n    # Remaining elements from nums2 (nums1 elements already in place)\n    while p2 >= 0:\n        nums1[write] = nums2[p2]\n        p2 -= 1\n        write -= 1\n    return nums1",
      "timeComplexity": "O(m+n)",
      "spaceComplexity": "O(1)",
      "explanation": "The key insight is to merge from the end. By placing the largest elements first (into the trailing zeros of nums1), we avoid overwriting any unprocessed elements. Compare the largest unplaced elements from each array and place the larger one at the write position, decrementing the pointers as we go.\n\nTime: O(m+n) | Space: O(1)"
    }
  ],
  "hints": [
    "Starting from the back avoids overwriting elements you haven't processed yet.",
    "Place the larger of the two current elements at the write pointer and advance accordingly."
  ],
  "lcEquivalent": "88. Merge Sorted Array"
}
