{
  "id": "search-2d-matrix",
  "title": "Search a 2D Matrix",
  "difficulty": "medium",
  "tags": ["binary-search", "matrix"],
  "description": "## Search a 2D Matrix\n\nYou are querying a distributed database where records are stored in a 2D grid. The grid has two important properties: each row is sorted left to right, and the first element of each row is strictly greater than the last element of the previous row. This means the entire grid, when read row by row, is one continuous sorted sequence.\n\nGiven an `m x n` integer matrix `matrix` and an integer `target`, return `true` if `target` is in the matrix, `false` otherwise.\n\nYou must solve this in **O(log(m * n))** time.\n\n**Constraints:**\n- `m == matrix.length`\n- `n == matrix[i].length`\n- `1 <= m, n <= 100`\n- `-10^4 <= matrix[i][j], target <= 10^4`",
  "examples": [
    {
      "input": "matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3",
      "output": "true",
      "explanation": "3 is at position [0][1] in the matrix."
    },
    {
      "input": "matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13",
      "output": "false",
      "explanation": "13 is not in the matrix."
    }
  ],
  "exampleCases": [
    {
      "input": {"matrix": [[1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 60]], "target": 3},
      "expected": true,
      "explanation": "Target found at [0][1]"
    },
    {
      "input": {"matrix": [[1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 60]], "target": 13},
      "expected": false,
      "explanation": "13 not in matrix"
    },
    {
      "input": {"matrix": [[1]], "target": 1},
      "expected": true,
      "explanation": "Single element, found"
    },
    {
      "input": {"matrix": [[1]], "target": 2},
      "expected": false,
      "explanation": "Single element, not found"
    }
  ],
  "hiddenCases": [
    {
      "input": {"matrix": [[1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 60]], "target": 1},
      "expected": true,
      "explanation": "First element"
    },
    {
      "input": {"matrix": [[1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 60]], "target": 60},
      "expected": true,
      "explanation": "Last element"
    },
    {
      "input": {"matrix": [[1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 60]], "target": 0},
      "expected": false,
      "explanation": "Less than minimum"
    },
    {
      "input": {"matrix": [[1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 60]], "target": 100},
      "expected": false,
      "explanation": "Greater than maximum"
    },
    {
      "input": {"matrix": [[1, 3], [5, 7]], "target": 5},
      "expected": true,
      "explanation": "2x2 matrix"
    },
    {
      "input": {"matrix": [[1, 3], [5, 7]], "target": 4},
      "expected": false,
      "explanation": "Between rows in 2x2"
    },
    {
      "input": {"matrix": [[1], [3], [5]], "target": 3},
      "expected": true,
      "explanation": "Single column matrix"
    },
    {
      "input": {"matrix": [[1, 2, 3, 4, 5]], "target": 3},
      "expected": true,
      "explanation": "Single row matrix"
    },
    {
      "input": {"matrix": [[1, 2, 3, 4, 5]], "target": 6},
      "expected": false,
      "explanation": "Single row, not found"
    },
    {
      "input": {"matrix": [[-10, -5], [0, 5], [10, 15]], "target": 0},
      "expected": true,
      "explanation": "Negative values present, target is 0"
    },
    {
      "input": {"matrix": [[-10, -5], [0, 5], [10, 15]], "target": -7},
      "expected": false,
      "explanation": "Between negative values"
    }
  ],
  "starterCode": {
    "python": "from typing import List\n\ndef search_matrix(matrix: List[List[int]], target: int) -> bool:\n    pass"
  },
  "functionName": "search_matrix",
  "solutions": [
    {
      "label": "Row-then-Column Search — O(m + n)",
      "approach": "obvious",
      "language": "python",
      "code": "from typing import List\n\ndef search_matrix(matrix: List[List[int]], target: int) -> bool:\n    m, n = len(matrix), len(matrix[0])\n    # Find the correct row\n    row = -1\n    for i in range(m):\n        if matrix[i][0] <= target <= matrix[i][n - 1]:\n            row = i\n            break\n    if row == -1:\n        return False\n    # Binary search in that row\n    left, right = 0, n - 1\n    while left <= right:\n        mid = left + (right - left) // 2\n        if matrix[row][mid] == target:\n            return True\n        elif matrix[row][mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return False",
      "timeComplexity": "O(m + log n)",
      "spaceComplexity": "O(1)",
      "explanation": "Linear scan to find the row whose range could contain the target (by checking row boundaries), then binary search within that row. The row scan is O(m) and the column search is O(log n).\n\nTime: O(m + log n) | Space: O(1)"
    },
    {
      "label": "Full Binary Search — O(log(m*n))",
      "approach": "optimal",
      "language": "python",
      "code": "from typing import List\n\ndef search_matrix(matrix: List[List[int]], target: int) -> bool:\n    m, n = len(matrix), len(matrix[0])\n    left, right = 0, m * n - 1\n    while left <= right:\n        mid = left + (right - left) // 2\n        row, col = divmod(mid, n)\n        val = matrix[row][col]\n        if val == target:\n            return True\n        elif val < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return False",
      "timeComplexity": "O(log(m*n))",
      "spaceComplexity": "O(1)",
      "explanation": "Treat the entire m*n matrix as a flat sorted array. Map any virtual index `mid` to row and column using divmod(mid, n). This lets us apply standard binary search on the virtual 1D array without actually flattening it.\n\nTime: O(log(m*n)) | Space: O(1)"
    }
  ],
  "hints": [
    "The matrix, read row by row, forms a single sorted sequence.",
    "You can treat the matrix as a 1D array and map index i to row=i//n, col=i%n."
  ],
  "lcEquivalent": "74. Search a 2D Matrix"
}
