{
  "id": "search-rotated-sorted",
  "title": "Search in Rotated Sorted Array",
  "difficulty": "medium",
  "tags": ["binary-search", "array"],
  "description": "## Search in Rotated Sorted Array\n\nYou are an archivist at a circular filing system. Records are stored in sorted order, but the storage drum has been rotated by an unknown amount. For example, `[4,5,6,7,0,1,2]` is the sorted array `[0,1,2,4,5,6,7]` rotated at index 4.\n\nGiven a sorted-then-rotated array `nums` of **distinct** integers and a `target`, return the **index** of `target`, or `-1` if not found.\n\nYou must achieve **O(log n)** runtime.\n\n**Constraints:**\n- `1 <= nums.length <= 5000`\n- `-10^4 <= nums[i], target <= 10^4`\n- All values of `nums` are **unique**.\n- `nums` is sorted and possibly rotated.",
  "examples": [
    {
      "input": "nums = [4, 5, 6, 7, 0, 1, 2], target = 0",
      "output": "4",
      "explanation": "0 is at index 4 in the rotated array."
    },
    {
      "input": "nums = [4, 5, 6, 7, 0, 1, 2], target = 3",
      "output": "-1",
      "explanation": "3 is not in the array."
    },
    {
      "input": "nums = [1], target = 0",
      "output": "-1",
      "explanation": "Single element, not target."
    }
  ],
  "exampleCases": [
    {
      "input": {"nums": [4, 5, 6, 7, 0, 1, 2], "target": 0},
      "expected": 4,
      "explanation": "Target in right (smaller) portion"
    },
    {
      "input": {"nums": [4, 5, 6, 7, 0, 1, 2], "target": 3},
      "expected": -1,
      "explanation": "Target not in array"
    },
    {
      "input": {"nums": [1], "target": 0},
      "expected": -1,
      "explanation": "Single element, not target"
    },
    {
      "input": {"nums": [1], "target": 1},
      "expected": 0,
      "explanation": "Single element, is target"
    }
  ],
  "hiddenCases": [
    {
      "input": {"nums": [3, 1], "target": 1},
      "expected": 1,
      "explanation": "Two elements, rotated"
    },
    {
      "input": {"nums": [5, 1, 3], "target": 5},
      "expected": 0,
      "explanation": "Target at start after rotation"
    },
    {
      "input": {"nums": [1, 3], "target": 3},
      "expected": 1,
      "explanation": "Not rotated, target at end"
    },
    {
      "input": {"nums": [6, 7, 1, 2, 3, 4, 5], "target": 7},
      "expected": 1,
      "explanation": "Target in left portion"
    },
    {
      "input": {"nums": [4, 5, 6, 7, 0, 1, 2], "target": 4},
      "expected": 0,
      "explanation": "Target at pivot start"
    },
    {
      "input": {"nums": [4, 5, 6, 7, 0, 1, 2], "target": 2},
      "expected": 6,
      "explanation": "Target at last index"
    },
    {
      "input": {"nums": [1, 2, 3, 4, 5], "target": 3},
      "expected": 2,
      "explanation": "Not rotated at all"
    },
    {
      "input": {"nums": [2, 3, 4, 5, 1], "target": 1},
      "expected": 4,
      "explanation": "Rotation at last position"
    },
    {
      "input": {"nums": [3, 4, 5, 1, 2], "target": 4},
      "expected": 1,
      "explanation": "Target in ascending left portion"
    },
    {
      "input": {"nums": [7, 8, 1, 2, 3, 4, 5, 6], "target": 6},
      "expected": 7,
      "explanation": "Target just before pivot"
    },
    {
      "input": {"nums": [9, 1, 2, 3, 4, 5, 6, 7, 8], "target": 9},
      "expected": 0,
      "explanation": "Single element before pivot"
    }
  ],
  "starterCode": {
    "python": "from typing import List\n\ndef search_rotated(nums: List[int], target: int) -> int:\n    pass"
  },
  "functionName": "search_rotated",
  "solutions": [
    {
      "label": "Linear Search — O(n)",
      "approach": "obvious",
      "language": "python",
      "code": "from typing import List\n\ndef search_rotated(nums: List[int], target: int) -> int:\n    for i, num in enumerate(nums):\n        if num == target:\n            return i\n    return -1",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "explanation": "Simple linear scan ignoring the sorted/rotated structure."
    },
    {
      "label": "Modified Binary Search — O(log n)",
      "approach": "optimal",
      "language": "python",
      "code": "from typing import List\n\ndef search_rotated(nums: List[int], target: int) -> int:\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = left + (right - left) // 2\n        if nums[mid] == target:\n            return mid\n        # Left half is sorted\n        if nums[left] <= nums[mid]:\n            if nums[left] <= target < nums[mid]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        # Right half is sorted\n        else:\n            if nums[mid] < target <= nums[right]:\n                left = mid + 1\n            else:\n                right = mid - 1\n    return -1",
      "timeComplexity": "O(log n)",
      "spaceComplexity": "O(1)",
      "explanation": "At each step, determine which half is sorted by comparing nums[left] with nums[mid]. The sorted half gives a clear range check — if target is in that range, search there; otherwise search the other half."
    }
  ],
  "hints": [
    "Even in a rotated array, at least one half of any binary search split is always sorted.",
    "Determine which half is sorted, then check if the target falls in that sorted range."
  ],
  "lcEquivalent": "33. Search in Rotated Sorted Array"
}
