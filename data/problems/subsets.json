{
  "id": "subsets",
  "title": "Subsets",
  "difficulty": "medium",
  "tags": ["backtracking", "array"],
  "description": "## Subsets\n\nYou are designing a feature selection tool for a machine learning pipeline. Given a set of distinct feature indices, you need to generate every possible subset of features to evaluate all possible model configurations — from using no features to using all of them.\n\nGiven an integer array `nums` of **unique** elements, return all possible subsets (the power set).\n\nThe solution set must **not contain duplicate subsets**. Return the answer in a consistent sorted order: each subset sorted, and the list of subsets sorted lexicographically.\n\n**Constraints:**\n- `1 <= nums.length <= 10`\n- `-10 <= nums[i] <= 10`\n- All the numbers of `nums` are unique.",
  "examples": [
    {
      "input": "nums = [1, 2, 3]",
      "output": "[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]",
      "explanation": "All 8 subsets of [1,2,3], sorted."
    },
    {
      "input": "nums = [0]",
      "output": "[[], [0]]",
      "explanation": "Two subsets: empty set and {0}."
    }
  ],
  "exampleCases": [
    {
      "input": {"nums": [1, 2, 3]},
      "expected": [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]],
      "explanation": "Power set of [1,2,3]"
    },
    {
      "input": {"nums": [0]},
      "expected": [[], [0]],
      "explanation": "Single element"
    },
    {
      "input": {"nums": [1, 2]},
      "expected": [[], [1], [1, 2], [2]],
      "explanation": "Power set of [1,2]"
    },
    {
      "input": {"nums": [4, 1, 0]},
      "expected": [[], [0], [0, 1], [0, 1, 4], [0, 4], [1], [1, 4], [4]],
      "explanation": "Unsorted input, output sorted"
    }
  ],
  "hiddenCases": [
    {
      "input": {"nums": [1]},
      "expected": [[], [1]],
      "explanation": "Single element"
    },
    {
      "input": {"nums": [1, 2, 3, 4]},
      "expected": [[], [1], [1, 2], [1, 2, 3], [1, 2, 3, 4], [1, 2, 4], [1, 3], [1, 3, 4], [1, 4], [2], [2, 3], [2, 3, 4], [2, 4], [3], [3, 4], [4]],
      "explanation": "16 subsets of [1,2,3,4]"
    },
    {
      "input": {"nums": [-1, 0, 1]},
      "expected": [[], [-1], [-1, 0], [-1, 0, 1], [-1, 1], [0], [0, 1], [1]],
      "explanation": "Negative values included"
    },
    {
      "input": {"nums": [5, 3]},
      "expected": [[], [3], [3, 5], [5]],
      "explanation": "Two element subset, sorted"
    },
    {
      "input": {"nums": [9, 0, 3, 5, 7]},
      "expected": [[], [0], [0, 3], [0, 3, 5], [0, 3, 5, 7], [0, 3, 5, 7, 9], [0, 3, 5, 9], [0, 3, 7], [0, 3, 7, 9], [0, 3, 9], [0, 5], [0, 5, 7], [0, 5, 7, 9], [0, 5, 9], [0, 7], [0, 7, 9], [0, 9], [3], [3, 5], [3, 5, 7], [3, 5, 7, 9], [3, 5, 9], [3, 7], [3, 7, 9], [3, 9], [5], [5, 7], [5, 7, 9], [5, 9], [7], [7, 9], [9]],
      "explanation": "5-element set, 32 subsets"
    },
    {
      "input": {"nums": [2, 4]},
      "expected": [[], [2], [2, 4], [4]],
      "explanation": "Two element"
    },
    {
      "input": {"nums": [-2]},
      "expected": [[], [-2]],
      "explanation": "Single negative"
    },
    {
      "input": {"nums": [10, -10]},
      "expected": [[], [-10], [-10, 10], [10]],
      "explanation": "Extremes"
    },
    {
      "input": {"nums": [1, 2, 3, 4, 5]},
      "expected": [[], [1], [1, 2], [1, 2, 3], [1, 2, 3, 4], [1, 2, 3, 4, 5], [1, 2, 3, 5], [1, 2, 4], [1, 2, 4, 5], [1, 2, 5], [1, 3], [1, 3, 4], [1, 3, 4, 5], [1, 3, 5], [1, 4], [1, 4, 5], [1, 5], [2], [2, 3], [2, 3, 4], [2, 3, 4, 5], [2, 3, 5], [2, 4], [2, 4, 5], [2, 5], [3], [3, 4], [3, 4, 5], [3, 5], [4], [4, 5], [5]],
      "explanation": "32 subsets of [1,2,3,4,5]"
    },
    {
      "input": {"nums": [3, 1]},
      "expected": [[], [1], [1, 3], [3]],
      "explanation": "Two elements, unsorted input"
    }
  ],
  "starterCode": {
    "python": "from typing import List\n\ndef subsets(nums: List[int]) -> List[List[int]]:\n    pass"
  },
  "functionName": "subsets",
  "solutions": [
    {
      "label": "Iterative Bit Masking — O(n * 2^n)",
      "approach": "obvious",
      "language": "python",
      "code": "from typing import List\n\ndef subsets(nums: List[int]) -> List[List[int]]:\n    nums.sort()\n    n = len(nums)\n    result = []\n    for mask in range(1 << n):\n        subset = [nums[i] for i in range(n) if mask & (1 << i)]\n        result.append(subset)\n    result.sort()\n    return result",
      "timeComplexity": "O(n * 2^n)",
      "spaceComplexity": "O(n * 2^n)",
      "explanation": "Each subset corresponds to a bitmask from 0 to 2^n - 1. Bit i set means nums[i] is included. Sort the output for determinism."
    },
    {
      "label": "Backtracking — O(n * 2^n)",
      "approach": "optimal",
      "language": "python",
      "code": "from typing import List\n\ndef subsets(nums: List[int]) -> List[List[int]]:\n    nums.sort()\n    result = []\n    def backtrack(start, current):\n        result.append(list(current))\n        for i in range(start, len(nums)):\n            current.append(nums[i])\n            backtrack(i + 1, current)\n            current.pop()\n    backtrack(0, [])\n    result.sort()\n    return result",
      "timeComplexity": "O(n * 2^n)",
      "spaceComplexity": "O(n * 2^n)",
      "explanation": "Backtracking: at each step, record the current subset, then try adding each remaining element. After adding an element and recursing, remove it (backtrack). This generates all 2^n subsets."
    }
  ],
  "hints": [
    "At each element, you make a binary choice: include it or not. This generates 2^n subsets.",
    "Backtracking: build subsets incrementally, recording each state, and undo choices as you go."
  ],
  "lcEquivalent": "78. Subsets"
}
