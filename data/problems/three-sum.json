{
  "id": "three-sum",
  "title": "Three Sum",
  "difficulty": "medium",
  "tags": ["array", "two-pointers", "sorting"],
  "description": "## Three Sum\n\nYou are a structural engineer analyzing stress measurements across beams. You need to find all groups of three beam readings that perfectly cancel each other out (sum to zero), indicating a balanced load.\n\nGiven an integer array `nums`, return all **unique triplets** `[nums[i], nums[j], nums[k]]` such that `i != j`, `i != k`, `j != k`, and `nums[i] + nums[j] + nums[k] == 0`.\n\nThe solution set must not contain duplicate triplets.\n\n**Note:** The returned list should be sorted: each triplet sorted in ascending order, and the outer list sorted lexicographically.\n\n**Constraints:**\n- `3 <= nums.length <= 3000`\n- `-10^5 <= nums[i] <= 10^5`",
  "examples": [
    {
      "input": "nums = [-1, 0, 1, 2, -1, -4]",
      "output": "[[-1, -1, 2], [-1, 0, 1]]",
      "explanation": "The triplets that sum to 0 are [-1,-1,2] and [-1,0,1]."
    },
    {
      "input": "nums = [0, 1, 1]",
      "output": "[]",
      "explanation": "No triplets sum to zero."
    },
    {
      "input": "nums = [0, 0, 0]",
      "output": "[[0, 0, 0]]",
      "explanation": "Only one unique triplet: [0,0,0]."
    }
  ],
  "exampleCases": [
    {
      "input": {"nums": [-1, 0, 1, 2, -1, -4]},
      "expected": [[-1, -1, 2], [-1, 0, 1]],
      "explanation": "Two unique zero-sum triplets"
    },
    {
      "input": {"nums": [0, 1, 1]},
      "expected": [],
      "explanation": "No valid triplets"
    },
    {
      "input": {"nums": [0, 0, 0]},
      "expected": [[0, 0, 0]],
      "explanation": "All zeros"
    },
    {
      "input": {"nums": [-2, 0, 1, 1, 2]},
      "expected": [[-2, 0, 2], [-2, 1, 1]],
      "explanation": "Two triplets"
    }
  ],
  "hiddenCases": [
    {
      "input": {"nums": [0, 0, 0, 0]},
      "expected": [[0, 0, 0]],
      "explanation": "Multiple zeros, only one unique triplet"
    },
    {
      "input": {"nums": [-4, -2, -2, -2, 0, 1, 2, 2, 2, 3, 3, 4, 4, 6, 6]},
      "expected": [[-4, -2, 6], [-4, 0, 4], [-4, 1, 3], [-4, 2, 2], [-2, -2, 4], [-2, 0, 2]],
      "explanation": "Many duplicates in input"
    },
    {
      "input": {"nums": [1, 2, 3]},
      "expected": [],
      "explanation": "All positive, no zero sum"
    },
    {
      "input": {"nums": [-1, -1, -1, 2]},
      "expected": [[-1, -1, 2]],
      "explanation": "Only one unique triplet despite duplicate -1s"
    },
    {
      "input": {"nums": [-5, 0, 5]},
      "expected": [[-5, 0, 5]],
      "explanation": "Exactly one triplet"
    },
    {
      "input": {"nums": [1, -1, 0]},
      "expected": [[-1, 0, 1]],
      "explanation": "Simple case"
    },
    {
      "input": {"nums": [-2, -2, 4]},
      "expected": [[-2, -2, 4]],
      "explanation": "Two same negatives"
    },
    {
      "input": {"nums": [3, 0, -2, -1, 1, 2]},
      "expected": [[-2, -1, 3], [-2, 0, 2], [-1, 0, 1]],
      "explanation": "Multiple triplets"
    },
    {
      "input": {"nums": [-1, 0, 1, 0]},
      "expected": [[-1, 0, 1]],
      "explanation": "Duplicate zero, still one unique triplet"
    },
    {
      "input": {"nums": [100000, -50000, -50000]},
      "expected": [[-50000, -50000, 100000]],
      "explanation": "Large values"
    },
    {
      "input": {"nums": [1, 1, 1, 1]},
      "expected": [],
      "explanation": "All same positive, no zero sum"
    }
  ],
  "starterCode": {
    "python": "from typing import List\n\ndef three_sum(nums: List[int]) -> List[List[int]]:\n    pass"
  },
  "functionName": "three_sum",
  "solutions": [
    {
      "label": "Brute Force — O(n³)",
      "approach": "obvious",
      "language": "python",
      "code": "from typing import List\n\ndef three_sum(nums: List[int]) -> List[List[int]]:\n    n = len(nums)\n    result_set = set()\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if nums[i] + nums[j] + nums[k] == 0:\n                    triplet = tuple(sorted([nums[i], nums[j], nums[k]]))\n                    result_set.add(triplet)\n    result = [list(t) for t in result_set]\n    result.sort()\n    return result",
      "timeComplexity": "O(n³)",
      "spaceComplexity": "O(n)",
      "explanation": "Check all triplets using three nested loops. Use a set of sorted tuples to automatically deduplicate. Sort the final result for consistent output."
    },
    {
      "label": "Sort + Two Pointers — O(n²)",
      "approach": "optimal",
      "language": "python",
      "code": "from typing import List\n\ndef three_sum(nums: List[int]) -> List[List[int]]:\n    nums.sort()\n    result = []\n    n = len(nums)\n    for i in range(n - 2):\n        if i > 0 and nums[i] == nums[i - 1]:\n            continue\n        left, right = i + 1, n - 1\n        while left < right:\n            total = nums[i] + nums[left] + nums[right]\n            if total == 0:\n                result.append([nums[i], nums[left], nums[right]])\n                while left < right and nums[left] == nums[left + 1]:\n                    left += 1\n                while left < right and nums[right] == nums[right - 1]:\n                    right -= 1\n                left += 1\n                right -= 1\n            elif total < 0:\n                left += 1\n            else:\n                right -= 1\n    return result",
      "timeComplexity": "O(n²)",
      "spaceComplexity": "O(1)",
      "explanation": "Sort the array. Fix the first element with an outer loop. Use two pointers for the remaining two elements. Skip duplicate values to avoid duplicate triplets. The sorted order ensures the output is already in canonical form."
    }
  ],
  "hints": [
    "Sort the array first. This makes duplicate skipping easy and enables two-pointer technique.",
    "Fix one element with an outer loop, then use two pointers (left and right) to find pairs that complete the triplet."
  ],
  "lcEquivalent": "15. 3Sum"
}
