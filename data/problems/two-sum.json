{
  "id": "two-sum",
  "title": "Two Sum",
  "difficulty": "easy",
  "tags": [
    "array",
    "hash-map"
  ],
  "description": "## Two Sum\n\nYou are a warehouse inventory manager. Your system stores a list of item weights, and you need to find two items whose combined weight exactly matches a shipping container's capacity.\n\nGiven an array of integers `nums` and an integer `target`, return the **indices** of the two numbers that add up to `target`.\n\nYou may assume that each input has **exactly one solution**, and you may not use the same element twice.\n\nYou can return the answer in any order.\n\n**Constraints:**\n- `2 <= nums.length <= 10^4`\n- `-10^9 <= nums[i] <= 10^9`\n- `-10^9 <= target <= 10^9`\n- Only one valid answer exists.",
  "examples": [
    {
      "input": "nums = [2, 7, 11, 15], target = 9",
      "output": "[0, 1]",
      "explanation": "nums[0] + nums[1] = 2 + 7 = 9, so we return [0, 1]."
    },
    {
      "input": "nums = [3, 2, 4], target = 6",
      "output": "[1, 2]",
      "explanation": "nums[1] + nums[2] = 2 + 4 = 6."
    }
  ],
  "exampleCases": [
    {
      "input": {
        "nums": [
          2,
          7,
          11,
          15
        ],
        "target": 9
      },
      "expected": [
        0,
        1
      ],
      "explanation": "2 + 7 = 9"
    },
    {
      "input": {
        "nums": [
          3,
          2,
          4
        ],
        "target": 6
      },
      "expected": [
        1,
        2
      ],
      "explanation": "2 + 4 = 6"
    },
    {
      "input": {
        "nums": [
          3,
          3
        ],
        "target": 6
      },
      "expected": [
        0,
        1
      ],
      "explanation": "3 + 3 = 6"
    },
    {
      "input": {
        "nums": [
          1,
          5,
          3,
          7,
          9
        ],
        "target": 12
      },
      "expected": [
        1,
        3
      ],
      "explanation": "5 + 7 = 12"
    }
  ],
  "hiddenCases": [
    {
      "input": {
        "nums": [
          0,
          4,
          3,
          0
        ],
        "target": 0
      },
      "expected": [
        0,
        3
      ],
      "explanation": "0 + 0 = 0"
    },
    {
      "input": {
        "nums": [
          -1,
          -2,
          -3,
          -4,
          -5
        ],
        "target": -8
      },
      "expected": [
        2,
        4
      ],
      "explanation": "-3 + -5 = -8"
    },
    {
      "input": {
        "nums": [
          1000000000,
          -1000000000
        ],
        "target": 0
      },
      "expected": [
        0,
        1
      ],
      "explanation": "Large positive and negative values"
    },
    {
      "input": {
        "nums": [
          2,
          5,
          5,
          11
        ],
        "target": 10
      },
      "expected": [
        1,
        2
      ],
      "explanation": "5 + 5 = 10"
    },
    {
      "input": {
        "nums": [
          1,
          2
        ],
        "target": 3
      },
      "expected": [
        0,
        1
      ],
      "explanation": "Minimum length array"
    },
    {
      "input": {
        "nums": [
          0,
          1
        ],
        "target": 1
      },
      "expected": [
        0,
        1
      ],
      "explanation": "Zero as one of the elements"
    },
    {
      "input": {
        "nums": [
          10,
          20,
          30,
          40,
          50
        ],
        "target": 90
      },
      "expected": [
        3,
        4
      ],
      "explanation": "40 + 50 = 90"
    },
    {
      "input": {
        "nums": [
          -3,
          4,
          3,
          90
        ],
        "target": 0
      },
      "expected": [
        0,
        2
      ],
      "explanation": "-3 + 3 = 0"
    },
    {
      "input": {
        "nums": [
          5,
          75,
          25
        ],
        "target": 100
      },
      "expected": [
        1,
        2
      ],
      "explanation": "75 + 25 = 100"
    },
    {
      "input": {
        "nums": [
          1,
          3,
          4,
          2
        ],
        "target": 6
      },
      "expected": [
        2,
        3
      ],
      "explanation": "4 + 2 = 6"
    },
    {
      "input": {
        "nums": [
          7,
          2,
          13,
          11,
          1
        ],
        "target": 9
      },
      "expected": [
        0,
        1
      ],
      "explanation": "7 + 2 = 9, indices [0, 1]"
    },
    {
      "input": {
        "nums": [
          2,
          8,
          3,
          5
        ],
        "target": 11
      },
      "expected": [
        1,
        2
      ],
      "explanation": "8 + 3 = 11"
    }
  ],
  "starterCode": {
    "python": "from typing import List\n\ndef two_sum(nums: List[int], target: int) -> List[int]:\n    pass"
  },
  "functionName": "two_sum",
  "solutions": [
    {
      "label": "Brute Force \u2014 O(n\u00b2)",
      "approach": "obvious",
      "language": "python",
      "code": "from typing import List\n\ndef two_sum(nums: List[int], target: int) -> List[int]:\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if nums[i] + nums[j] == target:\n                return [i, j]\n    return []",
      "timeComplexity": "O(n\u00b2)",
      "spaceComplexity": "O(1)",
      "explanation": "Check every pair of indices (i, j) where i < j. For each pair, test if their sum equals the target. Return the first matching pair found. Simple but slow for large inputs.\n\nTime: O(n\u00b2) | Space: O(1)"
    },
    {
      "label": "Hash Map \u2014 O(n)",
      "approach": "optimal",
      "language": "python",
      "code": "from typing import List\n\ndef two_sum(nums: List[int], target: int) -> List[int]:\n    seen = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i\n    return []",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "explanation": "The key insight is that for each number, there is exactly one other value that would complete the pair: target - num (the complement). As we iterate, we check if the complement is already in our hash map. If so, we found the answer. Otherwise, we store the current number and its index for future lookups. This single-pass approach trades space for time.\n\nTime: O(n) | Space: O(n)"
    }
  ],
  "hints": [
    "For each number, what value would you need to find to complete the pair?",
    "A hash map can tell you in O(1) whether a value has been seen before."
  ],
  "lcEquivalent": "1. Two Sum"
}